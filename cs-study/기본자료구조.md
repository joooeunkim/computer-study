## 기본 자료 구조 질문 모음

<details open>
  <summary> Array와 ArrayList의 차이를 설명하시오 </summary>

Array와 ArrayList는 모든 것이 비슷함.

가장 큰 차이점은 길이를 조절할 수 있는가 없는가 이다.

1. resizable

   java의 Array는 길이가 고정적이다.
   java의 ArrayList는 길이가 가변적이다. 하지만 내부적으로는 배열로 구성되어있다.

- ArrayList Object는 ArrayList의 size를 나타내는 capacity 변수를 가진다. ArrayList에 요소들이 더해지면, ArrayList의 capacity 또한 자동적으로 늘어난다. ArrayList의 devault 저장 용량은 10이다. 하지만 만약 capacity만큼 요소가 저장되면, 현재 배열 크기의 1.5배 크기의 새 배열을 생성후 기존의 배열을 copy 해준다.

2. performance

   Array나 ArrayList로부터 요소를 얻거나 추가할 때는 거의 비슷한 성능을 보인다.

3. primitives

   Array에는 primitive data type(int, float, double), object 둘다 저장 가능

   ArrayList에는 오로지 object type(Integer, Float, Double) 만 저장 가능

   - JVM은 Autoboxing(내부적으로 primitive type을 타입에 상응하는 object로 변환해주는 것, int => Integer)을 통해 ArrayList에 Object만 저장되도록 한다

4. Iterating values

   Array : for loop 아니면 for each loop를 통해 array를 순회할 수 있다.

   ArrayList : iterator를 사용해 ArrayList를 순회할 수 있다.

5. Length

   Array : Array의 길이를 반환하는 length 변수

   ArrayList : size() 메소드

   </details>

<details open>
  <summary> Array와 LinkedList 차이를 설명하시오 </summary>

- Array는 Random Access를 지원한다. 요소들을 인덱스를 통해 직접 접근할 수 있다. 따라서 특정 요소에 접근하는 시간 복잡도는 O(1)이다.
  반면 Linkedlist는 Sequential Access를 지원한다. 어떤 요소를 접근할 때 순차적으로 검색하며 찾아야 한다. 따라서 특정 요소에 접근할 때 시간 복잡도는 O(N)이다.
- 저장 방식도 배열에서 요소들은 인접한 메모리 위치에 연이어 저장된다.
  반면 Linkedlist에서는 새로운 요소에 할당된 메모리 위치 주소가 linkedlist의 이전 요소에 저장된다.
- 배열에서 삽입과 삭제는 O(N)이 소요되지만, Linkedlist에서 삽입과 삭제는 O(1)이 소요된다.
- 배열에서 메모리는 선언 시 컴파일 타임에 할당이 된다. (정적 메모리 할당)
  반면 Linkedlist에서는 새로운 요소가 추가될 때 런타임에 메모리를 할당한다. (동적 메모리 할당)
- 배열은 Stack 섹션에 메모리 할당이 이루어진다. 반면 Linkedlist는 Heap 섹션에 메모리 할당이 이루어진다.
- 결론 :

  - 삽입과 삭제가 빈번하다면 **LinkedList**를 사용하는 것이 더 좋다.
  - 데이터의 접근하는 게 중요하다면 **Array**를 사용하는 것이 좋다.

   </details>

<details open>
  <summary> ArrayList와 LinkedList 차이를 설명하시오 </summary>

ArrayList는 데이터들이 순서대로 늘어선 배열의 형식을 취하고 있지만, LinkedList는 자료의 주소값으로 서로 연결된 형식을 가지고 있다. 이러한 구조에 의해 둘은 각각의 장단점을 가지고 있습니다.

- ArrayList
  - 원하는 데이터에 무작위로 접근할 수 있다.
  - 리스트의 크기가 제한되어 있으며, 리스트의 크기를 재조정하는 것은 많은 연산이 필요하다.
  - 데이터의 추가/삭제를 위해서는 임시 배열을 생성하여 복제하고 있어 시간이 오래 걸린다.
- LinkedList
  - 리스트의 크기에 영향 없이 데이터를 추가할 수 있다.
  - 데이터를 추가하기 위해 새로운 노드를 생성하여 연결하므로 추가/삭제 연산이 빠르다.
  - 무작위 접근이 불가능하며, 순차 접근만이 가능하다.
  </details>

<details open>
  <summary> Array 사용 예시를 말해보시오 </summary>

</details>

<details open>
  <summary> 큐와 스택을 구현할 때 리스트와 array중 어떤 것으로 하는게 좋은가? </summary>
- 큐(Queue): Array로 구현하면 poll 연산 이후 객체를 앞당기는 작업이 필요하다. 하지만 List로 구현하면 객체 1개만 제거하면 되므로 삽입 및 삭제가 용이한 LinkedList로 구현하는 것이 좋다.
- 스택(Stack): List로 구현하면 객체를 제거하는 작업이 필요하다. 하지만 Array로 구현하면 삭제할 필요 없이 index를 줄이고 초기화만 하면 되므로, Array로 구현하는 것이 좋다.
</details>

<details open>
  <summary> 스택과 큐의 구조에 대해 실사용 예를 들어 설명하시오 </summary>
</details>

<details open>
  <summary> Tree에 관해 설명하시오 </summary>
</details>

<details open>
  <summary> Binary Tree와 Binary Search Tree에 대해 설명하시오 </summary>
</details>

<details open>
  <summary> 트리와 그래프의 차이 3가지 이상 말해보시오 </summary>
</details>

<details open>
  <summary> 그래프가 순환하는 지 판단하는 방법을 설명하시오 </summary>
</details>

<details open>
  <summary> BinaryTree의 순회방법에 대해 설명하시오 </summary>
</details>

<details open>
  <summary> BST의 최악의 경우의 예와 시간복잡도에 대해서 설명하시오 </summary>
</details>

<details open>
  <summary> 데크와 벡터의 차이에 대해 설명하시오 </summary>
</details>

<details open>
  <summary> Deque를 사용하는 이유에 대해 설명하시오 </summary>
</details>

<details open>
  <summary> 우선순위 큐의 동작 원리에 대해 설명하시오 </summary>
</details>

<details open>
  <summary> 힙을 사용하는 이유는 무엇인가? </summary>
</details>

<details open>
  <summary> 힙과 이진 탐색 트리의 공통점과 차이점 </summary>
</details>

<details open>
  <summary> Heap의 동작 원리에 대해서 설명하세요 </summary>
</details>

<details open>
  <summary> Priority Queue에서 Heap을 주로 사용하는 이유를 설명하세요 </summary>
</details>

<details open>
  <summary> 인덱스 트리가 쓰이는 경우에 대해 설명하시오 </summary>
</details>

<details open>
  <summary> 트라이 자료 구조의 장단점에 대해 설명하시오 </summary>
</details>

<details open>
  <summary> 인덱스 트리에 대해서 설명하시오 </summary>
</details>

<details open>
  <summary> 트라이 자료구조의 특징에 대해서 설명하시오 </summary>
</details>

<details open>
  <summary> B+tree의 장점에 대해 설명하시오 </summary>
</details>

<details open>
  <summary> 최소 신장 트리의 특징 3가지에 대해 설명하시오 </summary>
</details>

<details open>
  <summary> b-tree와 b+tree의 공통점과 차이점 </summary>
</details>

<details open>
  <summary> B-트리를 사용하는 이유에 대해서 설명하시오 </summary>
</details>

<details open>
  <summary> hashmap, hashtable의 원리를 설명하시오 </summary>
</details>

<details open>
  <summary> 해시 충돌이 발생하는 이유를 설명하시오 </summary>
</details>

<details open>
  <summary> 해시 테이블 충돌 해결방법 2가지를 설명하시오 </summary>
</details>

<details open>
  <summary> 해시맵과 해시테이블의 공통점과 차이점을 설명하시오 </summary>
</details>

<details open>
  <summary> 해시 테이블 시간 복잡도에 대해 설명하시오 </summary>
</details>
