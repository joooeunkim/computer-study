## 데이터베이스

데이터베이스(DB)는 일정한 규칙, 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음

데이터를 제어, 관리하는 통합 시스템을 DBMS(DataBase Management System)라고 한다

데이터베이스 안에 있는 데이터들은 특정 DBMS마다 정의된 쿼리 언어를 통해 삽입, 삭제, 수정, 조회 등을 수행할 수 있다.

- 엔터티(Entity)

  사람, 장소, 물건, 사건, 개념 등 여러 개의 속성을 지닌 명사. 예를 들어 회원이라는 엔터티의 경우 회원은 이름, 아이디, 주소, 전화번호의 속성을 가질 수 있다

  - 강한 엔터티, 약한 엔터티 : A가 혼자서는 존재하지 못하고 B의 존재여부에 따라 종속적이라면 A는 약한 엔텉, B는 강한 엔터티가 된다. 예를 들어 방은 건물 안에만 존재하기 때문에 방은 약한 엔터티라고 할 수 있고, 건물은 강한 엔터티라고 할 수 있다

- 릴레이션(Relation)

  데이터베이스에서 정보를 구분하여 저장하는 기본 단위. 엔터티에 관한 데이터를 데이터베이스는 릴레이션 하나에 담아서 관리한다.

  릴레이션은 관계형 데이터베이스에서는 '테이블'이라고 하며, NoSQL 데이터베이스에서는 '컬렉션' 이라고 한다.

- 속성(attribute)

  속성은 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보. 차라는 엔터티를 예시로 들었을 때 차 넘버, 바퀴 수, 차 색깔, 차종 등이 속성이고 이는 엔티티의 속성이 될 수 있다

- 도메인(domain)

  릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합. 예를 들어 성별이라는 속성이 있다면 이 속성이 가질 수 있는 값은 {남, 여} 라는 집합이다

- 필드와 레코드(field / record or tuple)

  엔터티는 속성인 여러 개의 필드를 가진다. 그리고 이 테이브렝 쌓이는 행 단위의 데이터를 레코드 또는 튜플이라고 한다.

### 키(Key)

데이터베이스에서 검색, 정렬 시 다른 튜플들과 구별할 수 있는 기준이 되는 Attribute(속성)

테이블 간의 관계를 조금 더 명확하게 하고 테이블 자체의 인덱스를 위해 설정된 장치

- 후보키 (Candidate Key): tuple을 유일하게 식별하기 위해 사용되는 속성들(기본키로 사용될 수 있는 속성들)의 부분집합

  - 모든 릴레이션은 반드시 하나 이상의 후보키를 가져야 한다
  - 유일성과 최소성 만족
    - 유일성 : Key로 하나의 tuple을 유일하게 식별할 수 있음
    - 최소성 : 꼭 필요한 속성으로만 구성
  - ex) 학번이나 주민번호

- 기본키 (Primary Key) : 후보키 중에서 선택한 주 키(Main Key)

  - Null값을 가질 수 없음 (개체 무결성 첫 번째 조건)
  - 동일한 값이 중복될 수 없음 (개체 무결성 두 번째 조건)
  - ex) 학번, 주민번호

- 대체키 (Alternate Key, 보조키) : 후보키 중 기본키를 제외한 나머지 키

  - ex) 학번을 기본키로 정의하면 주민번호는 대체키가 된다

- 슈퍼키 (Super Key) : 유일성은 만족하지만 최소성은 만족하지 못하는 키 -> 뭉쳤을 경우 유일성이 생기고, 흩어지면 몇몇 속성들은 독단적으로 유일성 있는 키로 사용할 수 없음

  - ex) 학번, 주민번호, 성명으로 슈퍼키 구성, 성명은 단독적으로 유일성 있는 키는 만족하지 못함

- 외래키 (Foreign Key) : 참조되는 릴레이션의 기본 키와 대응되어 릴레이션 간에 참조 관계를 표현하는 도구
  - 외래키로 지정시 참조 테이블의 기본 키에 없는 값은 입력할 수 없다(참조 무결성 조건)

### SQL - JOIN

RDBMS는 데이터 중복을 피하기 위해 테이블을 쪼개 나눠서 저장한다. 이렇게 분리되어 있는 데이터에서 원하는 결과를 조합해서 가져오기 위해서 테이블을 조합할 필요가 있고, 이를 join연산자를 통해 수행할 수 있다.

- Inner Join : 2개 이상의 테이블에서 교집합만 추출
- Outer Join : 한쪽에는 데이터가 있고 한쪽에는 데이터가 없는 경우, 데이터가 있는 쪽의 내용을 모두 출력하는 방법

  - Left Outer Join : 2개 이상의 테이블에서 from에 해당하는 부분을 추출
  - Right OuterJoin : 2개 이상의 테이블에서 from과 join하는 테이블에 해당하는 부분을 추출
  - Full Outer Join : 2개 이상의 테이블에서 모든 테이블에 해당하는 부분을 추출

- Cross Join : 두 테이블의 모든 행을 서로 조인한다. 결과값은 A 레코드 수 \* B 레코드 수

- Self Join : 자기 자신과 자기 자신을 조인

### SQL Injection

SQL인젝션은 웹 사이트의 보안상 허점을 이용해 특정 SQL 쿼리 문을 전송하여 공격자가 원하는 데이터베이스의 중요한 정보를 가져오는 해킹 기법.

대부분 클라이언트가 입력한 데이터를 제대로 필터링하지 못하는 경우에 발생한다.

공격의 쉬운 난이도에 비해 피해가 상당하기 때문에 보안 위협 1순위로 불릴만큼 중요한 기법.

간단한 쿼리문 조작을 통한 기법부터 자동화 스크립트를 통해 핵심 정보를 빼내오는 기법, 다량의 SQL Injection을 통한 기법까지 다양한 기법이 존재한다.

예시)
select \* from client where name = 'kimjooeun' and password = '12345'

select \* from client where name = 'kimjooeun' and password = 'or '1'='1

1과 1이 같으면 참이므로 1=1은 참이다.

SQL 인젝션 대응방안

1. 입력 값에 대한 검증

SQL Injection 에서 사용되는 기법과 키워드는 엄청나게 많습니다. 사용자의 입력 값에 대한 검증이 필요한데요. 서버 단에서 화이트리스트 기반으로 검증해야 합니다. 블랙리스트 기반으로 검증하게 되면 수많은 차단리스트를 등록해야 하고, 하나라도 빠지면 공격에 성공하게 되기 때문입니다. 공백으로 치환하는 방법도 많이 쓰이는데, 이 방법도 취약한 방법입니다. 예를 들어 공격자가 SESELECTLECT 라고 입력 시 중간의 SELECT가 공백으로 치환이 되면 SELECT 라는 키워드가 완성되게 됩니다. 공백 대신 공격 키워드와는 의미 없는 단어로 치환되어야 합니다.
입력값을 검증하여 사용자의 입력이 쿼리에 동적으로 영향을 주는 경우 입력된 값이 개발자가 의도한 값(유효값) 인지 검증합니다.

- Error based SQL Injection - 논리적 에러를 이용한 SQL Injection

  정상접근 -> Select \* from cliend where name='anjinma' and password='12345'

  SQL Injection -> Select \* from client where name='anjinma' and password=' or '1'='1'

  ' or '1'='1'를 넣어서 1과 1이 같아서 항상 참이므로 로그인에 성공하게 된다.

- UNION based SQL Injection = UNION 명령어를 이용한 SQL Injection

  select \* from users where id='test' UNION select 1,1 -- and PW='anything'

  쿼리가 실행되면 users 테이블에 등록된 id와 pw 목록을 전부 조회할 수 있게 된다.

- Blind SQL Injection - Boolean based Blind SQL Injection

  데이터베이스로부터 특정한 값이나 데이터를 전달받지 않고, 단순히 참과 거짓의 정보만 알 수 있을 때 사용합니다. 로그인 폼에 SQL Injection이 가능하다고 가정 했을 때, 서버가 응답하는 로그인 성공과 로그인 실패 메시지를 이용하여, DB의 테이블 정보 등을 추출해 낼 수 있습니다.

  (MySQL) 인젝션이 가능한 로그인 폼을 통하여 악의적인 사용자는 임의로 가입한 abc123 이라는 아이디와 함께 abc123’ and ASCII(SUBSTR(SELECT name From information_schema.tables WHERE table_type=’base table’ limit 0,1)1,1)) > 100 -- 이라는 구문을 주입합니다.

  해당구문은 MySQL 에서 테이블 명을 조회하는 구문으로 limit 키워드를 통해 하나의 테이블만 조회하고, SUBSTR 함수로 첫 글자만, 그리고 마지막으로 ASCII 를 통해서 ascii 값으로 변환해줍니다. 만약에 조회되는 테이블 명이 Users 라면 ‘U’ 자가 ascii 값으로 조회가 될 것이고, 뒤의 100 이라는 숫자 값과 비교를 하게 됩니다. 거짓이면 로그인 실패가 될 것이고, 참이 될 때까지 뒤의 100이라는 숫자를 변경해 가면서 비교를 하면 됩니다. 공격자는 이 프로세스를 자동화 스크립트를 통하여 단기간 내에 테이블 명을 알아 낼 수 있습니다.

- Blind SQL Injection - Time based SQL Injection

  Time Based SQL Injection 도 마찬가지로 서버로부터 특정한 응답 대신에 참 혹은 거짓의 응답을 통해서 데이터베이스의 정보를 유추하는 기법입니다. 사용되는 함수는 MySQL 기준으로 SLEEP 과 BENCHMARK 입니다.

  예로 로그인 폼에 주입이 되었으며 임의로 abc123 이라는 계정을 생성해 두었습니다. 악의적인 사용자가 abc123’ OR (LENGTH(DATABASE())=1 AND SLEEP(2)) – 이라는 구문을 주입하였습니다. 여기서 LENGTH 함수는 문자열의 길이를 반환하고, DATABASE 함수는 데이터베이스의 이름을 반환합니다.

  주입된 구문에서, LENGTH(DATABASE()) = 1 가 참이면 SLEEP(2) 가 동작하고, 거짓이면 동작하지 않습니다. 이를 통해서 숫자 1 부분을 조작하여 데이터베이스의 길이를 알아 낼 수 있습니다.

- Stored Procedure SQL Injection - 저장된 프로시저 에서의 SQL Injection

  저장 프로시저(Stored Procedure) 은 일련의 쿼리들을 모아 하나의 함수처럼 사용하기 위한 것입니다. 공격에 사용되는 대표적인 저장 프로시저는 MS-SQL 에 있는 xp_cmdshell로 윈도우 명령어를 사용할 수 있게 됩니다. 단, 공격자가 시스템 권한을 획득 해야 하므로 공격난이도가 높으나 공격에 성공한다면, 서버에 직접적인 피해를 입힐 수 있는 공격 입니다.

- Mass SQL Injection - 다량의 SQL Injection 공격

  2008년에 처음 발견된 공격기법으로 기존 SQL Injection 과 달리 한번의 공격으로 다량의 데이터베이스가 조작되어 큰 피해를 입히는 것을 의미합니다. 보통 MS-SQL을 사용하는 ASP 기반 웹 애플리케이션에서 많이 사용되며, 쿼리문은 HEX 인코딩 방식으로 인코딩 하여 공격합니다. 보통 데이터베이스 값을 변조하여 데이터베이스에 악성스크립트를 삽입하고, 사용자들이 변조된 사이트에 접속 시 좀비PC로 감염되게 합니다. 이렇게 감염된 좀비 PC들은 DDoS 공격에 사용됩니다.

2. Prepared Statement 구문사용

요즘에 쓰이는 거의 모든 데이터베이스 엔진은 유저 입력이 의도치 않은 동작을 하는 걸 방지하는 escape 함수와 prepared statement를 제공한다. prepared statement 는 변수를 문자열로 바꾸는것이라 안전하다.
Prepared Statement 구문을 사용하게 되면, 사용자의 입력 값이 데이터베이스의 파라미터로 들어가기 전에DBMS가 미리 컴파일 하여 실행하지 않고 대기합니다. 그 후 사용자의 입력 값을 문자열로 인식하게 하여 공격쿼리가 들어간다고 하더라도, 사용자의 입력은 이미 의미 없는 단순 문자열 이기 때문에 전체 쿼리문도 공격자의 의도대로 작동하지 않습니다.

3. Error Message 노출 금지

공격자가 SQL Injection을 수행하기 위해서는 데이터베이스의 정보(테이블명, 컬럼명 등)가 필요합니다. 데이터베이스 에러 발생 시 따로 처리를 해주지 않았다면, 에러가 발생한 쿼리문과 함께 에러에 관한 내용을 반환헤 줍니다. 여기서 테이블명 및 컬럼명 그리고 쿼리문이 노출이 될 수 있기 때문에, 데이터 베이스에 대한 오류발생 시 사용자에게 보여줄 수 있는 페이지를 제작 혹은 메시지박스를 띄우도록 하여야 합니다.

4. 웹 방화벽 사용

웹 공격 방어에 특화되어있는 웹 방화벽을 사용하는 것도 하나의 방법입니다. 웹 방화벽은 소프트웨어 형, 하드웨어 형, 프록시 형 이렇게 세가지 종류로 나눌 수 있는데 소프트웨어 형은 서버 내에 직접 설치하는 방법이고, 하드웨어 형은 네트워크 상에서 서버 앞 단에 직접 하드웨어 장비로 구성하는 것이며 마지막으로 프록시 형은 DNS 서버 주소를 웹 방화벽으로 바꾸고 서버로 가는 트래픽이 웹 방화벽을 먼저 거치도록 하는 방법입니다.

### SQL vs NoSQL

RDBMS : 모든 데이터를 2차원 테이블 형태로 표현

- 장점
  - 스키마에 맞춰 데이터를 관리하기 때문에 데이터의 정합성을 보장
  - 명확하게 정의된 스키마, 데이터 무결성 보장
  - 관계는 각 데이터를 중복없이 한번만 저장
- 단점
  - 시스템이 커질수록 쿼리가 복잡해지고 성능이 저하되며 Scale-out이 어렵다(Scale-up만 가능)
  - 덜 유연함. 데이터 스키마를 사전에 계획하고 알려야 함. (나중에 수정하기 힘듬)
  - 관계를 맺고 있어서 조인문이 많은 복잡한 쿼리가 만들어질 수 있음
- 데이터 구조가 명확하고, 변경 될 여지가 없으며 스키마가 중요한 경우 사용하는 것이 좋다. 중복된 데이터가 없어(데이터 무결성) 변경이 용이하기 때문에 관계를 맺고 있는 데이터가 자주 변경이 이루어지는 시스템에 적합.

NoSQL : RDBMS와 반대로 데이터간의 관계를 정의하지 않고, 스키마 대신 컬렉션이라는 형태로 데이터를 관리한다.

- 장점
  - 스키마 없이 Key-Value형태로 데이터를 관리해 자유롭게 데이터를 관리할 수 있다
  - 데이터 분산이 용이하여 성능향상을 위한 Scale-up 뿐만아닌 Scale-out 또한 가능하다.
  - 스키마가 없어서 유연함. 언제든지 저장된 데이터를 조정하고 새로운 필드 추가 가능
  - 데이터는 애플리케이션이 필요로 하는 형식으로 저장됨. 데이터 읽어오는 속도 빨라짐
  - 수직 및 수평 확장이 가능해서 애플리케이션이 발생시키는 모든 읽기/쓰기 요청 처리 가능
- 단점
  - 데이터 중복이 발생할 수 있고, 데이터가 여러 컬렉션에 중복되어 있기 때문에 수정 시 모든 컬렉션에서 수행해야 함 (SQL에서는 중복 데이터가 없으므로 한번만 수행이 가능)
  - 스키마가 존재하지 않기 때문에 명확한 데이터 구조를 보장하지 않아서 데이터 구조 결정이 어려울 수 있다
  - 유연성으로 인해 데이터 구조 결정을 미루게 될 수 있음
  - 데이터 중복을 계속 업데이트 해야 함
- 정확한 데이터 구조를 알 수 없고, 데이터가 변경/확장 될 수 있는 경우 사용하는 것이 좋다. 데이터 중복이 발생할 수 있기 때문에 중복된 데이터가 변경될 시 모든 컬렉션에서 수정해야하기 때문에 Update가 많이 이루어지지 않는 시스템에 좋으며 Scale-out이 가능하다는 장점을 활요해 막대한 데이터를 저장해야해서 DB를 Scale-out해야하는 시스템에 적합

DB 확장 2가지 방법

1. Scale Out : 접속된 서버를 여러대 추가하여 처리 능력을 향상하는 방법, 수평 스케일. 서버가 여러 대가 되기 때문에 각 서버에 걸리는 부하를 균등하게 해주는 로드 밸런싱이 필수적. 서버 한 대가 다운되더라도 다른 서버로 서비스 제공이 가능. 각각의 처리는 단순하지만 다수의 처리를 동시 병행적으로 실시하지 않으면 안되는 경우 적합하다. 갱신 데이터의 정합성에 대한 유지 요건이 별로 어렵지 않은 경우 적합하다. 모든 서버가 동일한 데이터를 가지고 있어야하기에 데이터 변화가 적은 웹서버에 적합하다.

2. Scale Up : 서버에 CPU나 RAM 등을 추가하거나 고성능의 부품, 서버로 교환하는 방법. 예를 들어 하나의 처리 능력을 가진 서버 한 대를 7의 처리 능력을 가진 서버로 그 자체의 처리능력을 향상하는 방법, 수직 스케일. 서버 한대로 모든 부하가 집중되어 장애시 크게 영향 받을 수 있음. 한 대의 서버에서 모든 데이터를 처리하여 데이터 갱신이 빈번하게 일어나는 '데이터베이스 서버'에 적합하다(여러 대의 서버에서 데이터의 정합성을 유지하기 어렵다).

### 이상 현상

이상현상이란, 테이블 내의 데이터들이 불필요하게 중복되어 테이블을 조작할 때 발생되는 데이터 불일치 현상. 테이블을 잘못 설계하여 삽입, 삭제, 갱신할 때 오류가 발생하게 되는 것.

삽입 이상 : 원하지 않는 자료가 삽입된다든지, key가 없어 삽입하지 못하는(불필요한 데이터를 추가해야 삽입할 수 있음) 문제점
갱신 이상 : 일부만 변경하여 데이터가 불일치하는 모순, 또는 중복되는 튜플이 존재하게 되는 문제점
삭제 이상 : 하나의 자료만 삭제하고 싶지만, 그 자료가 포함된 튜플 전체가 삭제됨으로 원하지 않는 정보 손실이 발생하는 문제점

정규화를 통해서 이상현상들을 해결

### 정규화

Attribute 간의 종속성으로 인한 이상현상이 발생하는 릴레이션을 분해하여 재디자인함으로써 이상현상을 없애는 과정

데이터의 중복 방지, 무결성을 충족하기 위해 데이터베이스를 설계하는 방법

정규화 3가지 원칙

1. 정보의 무손실 : 분해된 릴레이션이 표현하는 정보는 분해되기 전의 정보를 모두 포함해야 한다.

2. 최소 데이터 중복 : 이상 현상을 제거, 데이터 중복을 최소화

3. 분리의 원칙 : 하나의 독립된 관계성은 하나의 독립된 릴레이션으로 분리해서 표현

목적

1. 불필요한 데이터 (data redundancy)를 제거해 불필요한 중복을 최소화한다. 하나의 테이블에 모든 정보를 다 넣게 된다면, 동일한 정보들이 불필요하게 중복되어 저장될 수 있다.

2. 삽입/갱신/삭제 시 발생할 수 있는 각종 이상 현상(Anomaly)을 방지하기 위해서, 테이블의 구성을 논리적이고 직관적으로 한다.

그 외에 DB 구조 확장 시 재디자인을 최소화, 다양한 관점에서의 query를 지원하기 위해서 등등의 목적이 있다.

장단점

장점

- 데이터베이스 변경시 이상현상(Anomaly)를 방지
- 데이터 구조의 안정성 및 무결성을 유지
- 새로운 속성의 추가로 인해 DB 구조를 확장하는 경우, 구조의 변경을 최소화할 수 있다. 따라서 DB와 연동된 응용프로그램에 최소한의 영향만을 미쳐 응용프로그램의 생명을 연장시킨다.

단점

- 테이블이 클 경우 릴레이션간의 조인 연산 증가, 이로 인한 쿼리에 대한 응답시간 증가

과정

1. 제 1정규형 : 모든 도메인이 더이상 분해될 수 없는 원자값(atomic value)로만 구성되어야 한다. 한 개의 기본키에 대해 두 개 이상의 값을 가지지 않도록 해야한다.

2. 제 2정규형 : 제 1정규형을 만족하며 기본키를 제외한 모든 속성이 완전 함수적 종속이 되도록 테이블을 분해하는 것. 완전 함수적 종속이란, 기본키의 부분집합이 결정자가 되어선 안된다는 것(테이블에서 기본키가 복합키(키1, 키2)로 묶여있을 때, 두 키 중 하나의 키만으로 다른 컬럼을 결정지을 수 있으면 안된다.)

3. 제 3정규형 : 제 2정규형을 만족하며 이행적 함수 종속을 없애도록 테이블을 분해하는 것. 이행적 함수 종속은 A → B , B → C가 성립할 때 A → C가 성립되는 것을 의미

4. BCNF(보이스코드) 정규화 : 제3 정규화를 만족하며 결정자가 후보키가 아닌 함수 종속 관계를 제거하여 모든 결정자가 후보키가 되도록 테이블을 분해하는 것.

---

함수 종속성(Functional Dependency)은 어떤 테이블의 속성 A와 B에 대하여, A값에 의해 B값이 유일하게 정해지는 관계를 말하며, "B는 A에 함수 종속이다"라고 한다. A→B의 기호로 나타낸다.

이때, A를 결정자(Determinant)라고 하고, B를 종속자(Dependant)라고 한다.

함수 종속성은 크게 완전 함수 종속과 부분 함수 종속, 이행적 함수 종속으로 나뉜다.

- 완전 함수 종속 : 기본키를 구성하는 모든 속성에 종속되는 경우

- 부분 함수 종속 : 기본키를 구성하는 속성의 일부에 종속되거나, 기본키가 아닌 다른 속성에 종속되는 경우

- 이행적 함수 종속 : A, B, C 세 속성이 있고 A→B, B→C 종속 관계가 있을 때, A→C가 성립하는 경우

---

### 인덱스

인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조

특정 컬럼에 인덱스를 생성하면, 해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장됩니다. 이렇게 인덱스가 생성하였다면 앞으로 쿼리문에 "인덱스 생성 컬럼을 Where 조건으로 거는 등"의 작업을 하면 옵티마이저에서 판단하여 생성된 인덱스를 탈 수가 있습니다. 만약 인덱스를 타게 되면 아래의 그림과 같이 인덱스를 타게 되고 먼저 인덱스에 저장되어 있는 데이터의 물리적 주소로 가서 데이터를 가져오는 식으로 동작을 하여 검색 속도의 향상을 가져올 수 있습니다.

- 장점
  - 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
  - 전반적인 시스템의 부하를 줄일 수 있다.
- 단점

  - 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다.
  - 인덱스를 관리하기 위해 추가 작업이 필요하다.
  - 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있다.

    만약 CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 비대해져서 성능이 오히려 저하되는 역효과가 발생할 수 있다. 그러한 이유 중 하나는 DELETE와 UPDATE 연산 때문이다. 앞에서 설명한대로, UPDATE와 DELETE는 기존의 인덱스를 삭제하지 않고 '사용하지 않음' 처리를 해준다고 하였다. 만약 어떤 테이블에 UPDATE와 DELETE가 빈번하게 발생된다면 실제 데이터는 10만건이지만 인덱스는 100만 건이 넘어가게 되어, SQL문 처리 시 비대해진 인덱스에 의해 오히려 성능이 떨어지게 될 것이다.

인덱스를 사용하면 좋은 경우

- 규모가 작지 않은 테이블
- INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
- JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
- 데이터의 중복도가 낮은 컬럼

인덱스를 사용하는 것 만큼이나 생성된 인덱스를 관리해주는 것도 중요하다. 그러므로 사용되지 않는 인덱스는 바로 제거를 해주어야 한다.

### 트랜잭션

데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위

트랜잭션은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 수행되어야할 일련의 연산들을 의미

트랜잭션은 작업의 완전성을 보장해준다. 즉, 논리적인 작업 셋을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능

트랜잭션은 SELECT, UPDATE, INSERT, DELETE와 같은 연산을 수행하여 데이터베이스의 상태를 변화시키는 작업의 단위

단위별로 내부의 쿼리들은 하나로 묶이기 때문에 안에서 하나의 쿼리만 실행되고 나머지는 실행되지 않는 현상을 막고 하나의 쿼리처럼 동작하게 한다.

트랜잭션 필요성

- 트랜잭션은 작업의 완전성을 보장해주는 것입니다.

- 논리적인 작업들을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우 이전 상태로 복구하여 작업의 일부만 적용되는 현상이 발생하지 않게 만들어 주는 기능입니다.

연산

트랜잭션을 수행 중에 작업이 실패하는 경우가 발생할 수 있다. 이러한 상황을 방지하기 위해서 데이터베이스에서는 commit과 rollback 연산을 수행하여 트랜잭션 결과를 저장 또는 원복

Commit

    트랜잭션의 모든 작업이 수행된 후에 작업의 결과, 데이터베이스의 상태 변화를 저장하기 작업 완료를 알려준다. 이 연산을 수행하면 수행했던 트랜잭션이 로그에 저장되고, 후에 Rollback 연산을 수행하는 경우 트랜잭션 단위로 원복을 할 수 있도록 해준다.

Rollback

    만약 트랜잭션이 정상적으로 모든 작업을 수행하지 못한 경우에 트랜잭션 수행 전으로 데이터베이스를 원복한다. 트랜잭션의 처리 단위대로 원복할 수 있다.

특징

- 원자성 (Atomicity), All or nothing - 트랜잭션의 모든 연산들은 정상적으로 수행 완료되거나 아니면 전혀 어떠한 연산도 수행되지 않은 상태를 보장해야
  한다

- 일관성 (Consistency) - 트랜잭션은 완료 후에도 데이터베이스가 일관된 상태로 유지되어야 한다

- 독립성 (Isolation) - 하나의 트랜잭션이 실행하는 도중에 변경한 데이터는 이 트랜잭션이 완료될 때 까지 다른 트랜잭션이 참조하지 못한다

- 지속성 (Durability) - 성공적으로 수행 된 트랜잭션은 영원히 반영되어야 한다

트랜잭션 격리 수준(Transaction Isolation Levels)

트랜잭션 격리 수준이랑 동시에 여러 트랜잭션이 처리될 때, 트랜잭션끼리 얼마나 고립되어 있는지를 나타내는 것

READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE 크게 네 가지로 나뉘고 순서대로 뒤로 갈수록 트랜잭션 간 고립 정도가 높아진다. 고립 정도가 높아지면, 성능이 떨어지는 것이 일반적이다.

보통의 경우 READ COMMITTED(oracle), REPEATABLE READ(mysql) 중 하나를 사용한다.

Isolation Level 이란?

- 트랜잭션에서 일관성이 없는 데이터를 허용하도록 하는 수준
- 즉, 한 트랜잭션이 다른 트랜잭션이 변경한 데이터에 대한 접근 강도를 의미

Isolation Level 의 필요성

- 데이터베이스는 ACID 같이 트랜잭션이 원자적이면서도 독립적인 수행을 하도록 한다
- 그래서 Locking 이라는 개념이 등장한다
  - 트랜잭션이 DB 를 다루는 동안 다른 트랜잭션이 관여하지 못하게 막는 것
- 하지만 무조건적인 Locking 으로 동시에 수행되는 많은 트랜잭션들을 순서대로 처리하는 방식으로 구현되면 DB
  의 성능은 떨어지게 된다
- 반대로 응답성을 높이기 위해 Locking 범위를 줄인다면 잘못된 값이 처리 될 여지가 있다
- 그래서 최대한 효율적인 Locking 방법이 필요하다

Isolation Level 의 종류

1.  Read Uncommitted (레벨 0) = A트랜잭션 중 커밋되지 않은 데이터를 B트랜잭션에서 읽기가능 - select 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는 Level - 트랜잭션에 처리중인 혹은 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용한다 - 따라서, 어떤 사용자가 A라는 데이터를 B라는 데이터로 변경하는 동안 다른 사용자는 아직 완료되지 않은
    (Uncommitted 혹은 Dirty) 트랜잭션이지만 변경된 데이터인 B를 읽을 수 있다 - 데이터베이스 일관성을 유지할 수 없다

2.  Read Committed (레벨 1) = A트랜잭션이 커밋하지 않는다면 B트랜잭션에서 A 데이터를 읽을 수 없다 (기본값)

    - select 문장이 수행되는 동안 해당 데이터에 Shared Lock 이 걸리는 Level
    - 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하게 된다
    - Commit이 이루어진 트랜잭션만 조회할 수 있다
    - 따라서, 어떤 사용자가 A라는 데이터를 B라는 데이터로 변경하는 동안 다른 사용자는 해당 데이터에 접근 할 수 없다
    - SQL Server가 Default 로 사용하는 Isolation Level

3.  Repeatable Read (레벨 2)

    - 트랜잭션이 완료될 때까지 select 문장이 사용하는 모든 데이터에 Shared Lock 이 걸리는 Level
    - 트랜잭션이 범위 내에서 조회한 데이터의 내용이 항상 동일함을 보장한다
    - 따라서, 다른 사용자는 그 영역에 해당되는 데이터 대한 수정이 불가능하다
    - 예) member 조회, board 조회, post 조회 시 Lock 이 걸리고, commit 또는 rollback 될 때 까지 접근 불가?

4.  Serializable (레벨 3)
    - 트랜잭션이 완료 될 때까지 select 문장이 사용되는 모든 데이터에 Shared Lock 걸리는 Level
    - 완벽한 읽기 일관성 모드를 제공한다
    - 따라서, 다른 사용자는 그 영역에 해당되는 데이터에 대한 수정 및 입력이 불가능하다

- Isolation Level 조정은 동시성이 증가되는데 반해 데이터 무결성에 문제가 발생할 수 있고,
  데이터의 무결성을 유지하는 데 반해 동시성 떨어질 수 있다
- level 이 높아질 수록 비용이 높아진다

  동시성 데이터 무결성
  ISO LEVEL ↑ ↑ ↓
  ISO LEVEL ↓ ↓ ↑

낮은 단계의 Isolation Level 이용시 발생하는 현상

- Dirty Read
  - 커밋되지 않은 수정 중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생하는 현상
    어떤 트랜잭션에서 아직 실행이 끝난지 않은 다른 트랜잭션에 의한 변경 사항을 보게 되는 되는 경우
- Non-Repeatable Read
  - 한 트랜잭션에서 같은 쿼리를 두 번 수행할 때 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제함으로써 두 쿼리의 결과가 상이하게 나타나는 비 일관성 현상
- Phantom Read
  - 한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽을 때, 첫 번째 쿼리에서 없던 레코드가 두 번째 쿼리에서 나타나는 현상
    이는 트랜잭션 도중 새로운 레코드가 삽입되는 것을 허용하기 때문에 나타난다.

### 저장 프로시저

저장 프로시저는 사전 컴파일 된 SQL 쿼리의 모음으로, 사전에 준비해 둔 많은 명령을 자동으로 실행할 수 있기 때문에 작업의 효율성도 높일 수 있다.

데이터베이스에 저장된 SQL명령문을 하나의 함수처럼 실행하기 위한 Query(쿼리)의 집합이다. 같은 쿼리를 반복할 필요가 없어 속도가 빠르고 에러 확률을 감소시킨다.

프로시저 장점

1. 최적화 & 캐시

   프로시저의 최초 실행 시 최적화 상태로 컴파일이 되며, 그 이후 프로시저 캐시에 저장된다.
   만약 해당 프로세스가 여러번 사용될 때, 다시 컴파일 작업을 거치지 않고 캐시에서 가져오게 된다.

2. 유지 보수
   작업이 변경될 때, 다른 작업은 건드리지 않고 프로시저 내부에서 수정만 하면 된다. (But, 장점이 단점이 될 수도 있는 부분이기도.. )

3. 트래픽 감소
   클라이언트가 직접 SQL문을 작성하지 않고, 프로시저명에 매개변수만 담아 전달하면 된다. 즉, SQL문이 서버에 이미 저장되어 있기 때문에 클라이언트와 서버 간 네트워크 상 트래픽이 감소된다.

4. 보안
   프로시저 내에서 참조 중인 테이블의 접근을 막을 수 있다.

프로시저 단점

1. 호환성
   구문 규칙이 SQL / PSM 표준과의 호환성이 낮기 때문에 코드 자산으로의 재사용성이 나쁘다.

2. 성능
   문자 또는 숫자 연산에서 프로그래밍 언어인 C나 Java보다 성능이 느리다.

3. 디버깅
   에러가 발생했을 때, 어디서 잘못됐는지 디버깅하는 것이 힘들 수 있다.

### Redis

빠른 오픈 소스 인 메모리 키 값 데이터 구조 스토어

보통 데이터베이스는 하드 디스크나 SSD에 저장한다. 하지만 Redis는 메모리(RAM)에 저장해서 디스크 스캐닝이 필요없어 매우 빠른 장점이 존재함

캐싱도 가능해 실시간 채팅에 적합하며 세션 공유를 위해 세션 클러스터링에도 활용된다.

RAM은 휘발성 아닌가요? 껐다키면 다 날아가는데..

이를 막기위한 백업 과정이 존재한다.(영속성이 있다!)

- snapshot : 특정 지점을 설정하고 디스크에 백업
- AOF(Append Only File) : 명령(쿼리)들을 저장해두고, 서버가 셧다운되면 재실행해서 다시 만들어 놓는 것
  데이터 구조는 key/value 값으로 이루어져 있다. (따라서 Redis는 비정형 데이터를 저장하는 비관계형 데이터베이스 관리 시스템이다)

데이터 구조는 key/value 값으로 이루어져 있다. (따라서 Redis는 비정형 데이터를 저장하는 비관계형 데이터베이스 관리 시스템이다)

value 5가지 종류(

1. String (text, binary data) - 512MB까지 저장이 가능함
2. set (String 집합)
3. sorted set (set을 정렬해둔 상태)
4. Hash
5. List (양방향 연결리스트도 가능)

   )

Redis의 장점

1. 리스트, 배열과 같은 데이터를 처리하는데 유용합니다.
2. Message Queue, Shared Memory, Remote Dictionary(RDBMS의 캐시 솔루션 / read 속도가 매우 빠릅니다.) 용도로 사용됩니다.
3. 메모리를 활용하면서 데이터를 보존합니다.
4. Redis Server는 1개의 싱글 쓰레드로 수행되며, 서버 하나에 여러개의 서버를 띄우는 것이 가능합니다.

Redis와 MongoDB의 차이

- 둘다 NO SQL 방식
- MongoDB는 document(json)형식으로 데이터 저장, Redis는 Key/Value 형태로 데이터를 저장
- Redis는 인메모리DB로 데이터를 저장하고 관리하여 성능이 좋지만 캐쉬등과 같이 유한성과 저장기간이 있어 빠른 성능이 필요한 기능에 사용
- MongoDB는 방대한 데이터나 가변적인 데이터 구조를 다루는데 유용함
