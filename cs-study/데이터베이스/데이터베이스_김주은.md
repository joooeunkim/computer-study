## 데이터베이스

데이터베이스(DB)는 일정한 규칙, 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음

데이터를 제어, 관리하는 통합 시스템을 DBMS(DataBase Management System)라고 한다

데이터베이스 안에 있는 데이터들은 특정 DBMS마다 정의된 쿼리 언어를 통해 삽입, 삭제, 수정, 조회 등을 수행할 수 있다.

- 엔터티(Entity)

  사람, 장소, 물건, 사건, 개념 등 여러 개의 속성을 지닌 명사. 예를 들어 회원이라는 엔터티의 경우 회원은 이름, 아이디, 주소, 전화번호의 속성을 가질 수 있다

  - 강한 엔터티, 약한 엔터티 : A가 혼자서는 존재하지 못하고 B의 존재여부에 따라 종속적이라면 A는 약한 엔텉, B는 강한 엔터티가 된다. 예를 들어 방은 건물 안에만 존재하기 때문에 방은 약한 엔터티라고 할 수 있고, 건물은 강한 엔터티라고 할 수 있다

- 릴레이션(Relation)

  데이터베이스에서 정보를 구분하여 저장하는 기본 단위. 엔터티에 관한 데이터를 데이터베이스는 릴레이션 하나에 담아서 관리한다.

  릴레이션은 관계형 데이터베이스에서는 '테이블'이라고 하며, NoSQL 데이터베이스에서는 '컬렉션' 이라고 한다.

- 속성(attribute)

  속성은 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보. 차라는 엔터티를 예시로 들었을 때 차 넘버, 바퀴 수, 차 색깔, 차종 등이 속성이고 이는 엔티티의 속성이 될 수 있다

- 도메인(domain)

  릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합. 예를 들어 성별이라는 속성이 있다면 이 속성이 가질 수 있는 값은 {남, 여} 라는 집합이다

- 필드와 레코드(field / record or tuple)

  엔터티는 속성인 여러 개의 필드를 가진다. 그리고 이 테이브렝 쌓이는 행 단위의 데이터를 레코드 또는 튜플이라고 한다.

### 키(Key)

데이터베이스에서 검색, 정렬 시 다른 튜플들과 구별할 수 있는 기준이 되는 Attribute(속성)

테이블 간의 관계를 조금 더 명확하게 하고 테이블 자체의 인덱스를 위해 설정된 장치

- 후보키 (Candidate Key): tuple을 유일하게 식별하기 위해 사용되는 속성들(기본키로 사용될 수 있는 속성들)의 부분집합

  - 모든 릴레이션은 반드시 하나 이상의 후보키를 가져야 한다
  - 유일성과 최소성 만족
    - 유일성 : Key로 하나의 tuple을 유일하게 식별할 수 있음
    - 최소성 : 꼭 필요한 속성으로만 구성
  - ex) 학번이나 주민번호

- 기본키 (Primary Key) : 후보키 중에서 선택한 주 키(Main Key)

  - Null값을 가질 수 없음 (개체 무결성 첫 번째 조건)
  - 동일한 값이 중복될 수 없음 (개체 무결성 두 번째 조건)
  - ex) 학번, 주민번호

- 대체키 (Alternate Key, 보조키) : 후보키 중 기본키를 제외한 나머지 키

  - ex) 학번을 기본키로 정의하면 주민번호는 대체키가 된다

- 슈퍼키 (Super Key) : 유일성은 만족하지만 최소성은 만족하지 못하는 키 -> 뭉쳤을 경우 유일성이 생기고, 흩어지면 몇몇 속성들은 독단적으로 유일성 있는 키로 사용할 수 없음

  - ex) 학번, 주민번호, 성명으로 슈퍼키 구성, 성명은 단독적으로 유일성 있는 키는 만족하지 못함

- 외래키 (Foreign Key) : 참조되는 릴레이션의 기본 키와 대응되어 릴레이션 간에 참조 관계를 표현하는 도구
  - 외래키로 지정시 참조 테이블의 기본 키에 없는 값은 입력할 수 없다(참조 무결성 조건)

### SQL - JOIN

RDBMS는 데이터 중복을 피하기 위해 테이블을 쪼개 나눠서 저장한다. 이렇게 분리되어 있는 데이터에서 원하는 결과를 조합해서 가져오기 위해서 테이블을 조합할 필요가 있고, 이를 join연산자를 통해 수행할 수 있다.

- Inner Join : 2개 이상의 테이블에서 교집합만 추출
- Outer Join : 한쪽에는 데이터가 있고 한쪽에는 데이터가 없는 경우, 데이터가 있는 쪽의 내용을 모두 출력하는 방법

  - Left Outer Join : 2개 이상의 테이블에서 from에 해당하는 부분을 추출
  - Right OuterJoin : 2개 이상의 테이블에서 from과 join하는 테이블에 해당하는 부분을 추출
  - Full Outer Join : 2개 이상의 테이블에서 모든 테이블에 해당하는 부분을 추출

- Cross Join : 두 테이블의 모든 행을 서로 조인한다. 결과값은 A 레코드 수 \* B 레코드 수

- Self Join : 자기 자신과 자기 자신을 조인

### SQL Injection

SQL인젝션은 웹 사이트의 보안상 허점을 이용해 특정 SQL 쿼리 문을 전송하여 공격자가 원하는 데이터베이스의 중요한 정보를 가져오는 해킹 기법.

대부분 클라이언트가 입력한 데이터를 제대로 필터링하지 못하는 경우에 발생한다.

공격의 쉬운 난이도에 비해 피해가 상당하기 때문에 보안 위협 1순위로 불릴만큼 중요한 기법.

간단한 쿼리문 조작을 통한 기법부터 자동화 스크립트를 통해 핵심 정보를 빼내오는 기법, 다량의 SQL Injection을 통한 기법까지 다양한 기법이 존재한다.

예시)
select \* from client where name = 'kimjooeun' and password = '12345'

select \* from client where name = 'kimjooeun' and password = 'or '1'='1

1과 1이 같으면 참이므로 1=1은 참이다.

SQL 인젝션 대응방안

1. 입력 값에 대한 검증

SQL Injection 에서 사용되는 기법과 키워드는 엄청나게 많습니다. 사용자의 입력 값에 대한 검증이 필요한데요. 서버 단에서 화이트리스트 기반으로 검증해야 합니다. 블랙리스트 기반으로 검증하게 되면 수많은 차단리스트를 등록해야 하고, 하나라도 빠지면 공격에 성공하게 되기 때문입니다. 공백으로 치환하는 방법도 많이 쓰이는데, 이 방법도 취약한 방법입니다. 예를 들어 공격자가 SESELECTLECT 라고 입력 시 중간의 SELECT가 공백으로 치환이 되면 SELECT 라는 키워드가 완성되게 됩니다. 공백 대신 공격 키워드와는 의미 없는 단어로 치환되어야 합니다.
입력값을 검증하여 사용자의 입력이 쿼리에 동적으로 영향을 주는 경우 입력된 값이 개발자가 의도한 값(유효값) 인지 검증합니다.

- Error based SQL Injection - 논리적 에러를 이용한 SQL Injection

  정상접근 -> Select \* from cliend where name='anjinma' and password='12345'

  SQL Injection -> Select \* from client where name='anjinma' and password=' or '1'='1'

  ' or '1'='1'를 넣어서 1과 1이 같아서 항상 참이므로 로그인에 성공하게 된다.

- UNION based SQL Injection = UNION 명령어를 이용한 SQL Injection

  select \* from users where id='test' UNION select 1,1 -- and PW='anything'

  쿼리가 실행되면 users 테이블에 등록된 id와 pw 목록을 전부 조회할 수 있게 된다.

- Blind SQL Injection - Boolean based Blind SQL Injection

  데이터베이스로부터 특정한 값이나 데이터를 전달받지 않고, 단순히 참과 거짓의 정보만 알 수 있을 때 사용합니다. 로그인 폼에 SQL Injection이 가능하다고 가정 했을 때, 서버가 응답하는 로그인 성공과 로그인 실패 메시지를 이용하여, DB의 테이블 정보 등을 추출해 낼 수 있습니다.

  (MySQL) 인젝션이 가능한 로그인 폼을 통하여 악의적인 사용자는 임의로 가입한 abc123 이라는 아이디와 함께 abc123’ and ASCII(SUBSTR(SELECT name From information_schema.tables WHERE table_type=’base table’ limit 0,1)1,1)) > 100 -- 이라는 구문을 주입합니다.

  해당구문은 MySQL 에서 테이블 명을 조회하는 구문으로 limit 키워드를 통해 하나의 테이블만 조회하고, SUBSTR 함수로 첫 글자만, 그리고 마지막으로 ASCII 를 통해서 ascii 값으로 변환해줍니다. 만약에 조회되는 테이블 명이 Users 라면 ‘U’ 자가 ascii 값으로 조회가 될 것이고, 뒤의 100 이라는 숫자 값과 비교를 하게 됩니다. 거짓이면 로그인 실패가 될 것이고, 참이 될 때까지 뒤의 100이라는 숫자를 변경해 가면서 비교를 하면 됩니다. 공격자는 이 프로세스를 자동화 스크립트를 통하여 단기간 내에 테이블 명을 알아 낼 수 있습니다.

- Blind SQL Injection - Time based SQL Injection

  Time Based SQL Injection 도 마찬가지로 서버로부터 특정한 응답 대신에 참 혹은 거짓의 응답을 통해서 데이터베이스의 정보를 유추하는 기법입니다. 사용되는 함수는 MySQL 기준으로 SLEEP 과 BENCHMARK 입니다.

  예로 로그인 폼에 주입이 되었으며 임의로 abc123 이라는 계정을 생성해 두었습니다. 악의적인 사용자가 abc123’ OR (LENGTH(DATABASE())=1 AND SLEEP(2)) – 이라는 구문을 주입하였습니다. 여기서 LENGTH 함수는 문자열의 길이를 반환하고, DATABASE 함수는 데이터베이스의 이름을 반환합니다.

  주입된 구문에서, LENGTH(DATABASE()) = 1 가 참이면 SLEEP(2) 가 동작하고, 거짓이면 동작하지 않습니다. 이를 통해서 숫자 1 부분을 조작하여 데이터베이스의 길이를 알아 낼 수 있습니다.

- Stored Procedure SQL Injection - 저장된 프로시저 에서의 SQL Injection

  저장 프로시저(Stored Procedure) 은 일련의 쿼리들을 모아 하나의 함수처럼 사용하기 위한 것입니다. 공격에 사용되는 대표적인 저장 프로시저는 MS-SQL 에 있는 xp_cmdshell로 윈도우 명령어를 사용할 수 있게 됩니다. 단, 공격자가 시스템 권한을 획득 해야 하므로 공격난이도가 높으나 공격에 성공한다면, 서버에 직접적인 피해를 입힐 수 있는 공격 입니다.

- Mass SQL Injection - 다량의 SQL Injection 공격

  2008년에 처음 발견된 공격기법으로 기존 SQL Injection 과 달리 한번의 공격으로 다량의 데이터베이스가 조작되어 큰 피해를 입히는 것을 의미합니다. 보통 MS-SQL을 사용하는 ASP 기반 웹 애플리케이션에서 많이 사용되며, 쿼리문은 HEX 인코딩 방식으로 인코딩 하여 공격합니다. 보통 데이터베이스 값을 변조하여 데이터베이스에 악성스크립트를 삽입하고, 사용자들이 변조된 사이트에 접속 시 좀비PC로 감염되게 합니다. 이렇게 감염된 좀비 PC들은 DDoS 공격에 사용됩니다.

2. Prepared Statement 구문사용

요즘에 쓰이는 거의 모든 데이터베이스 엔진은 유저 입력이 의도치 않은 동작을 하는 걸 방지하는 escape 함수와 prepared statement를 제공한다. prepared statement 는 변수를 문자열로 바꾸는것이라 안전하다.
Prepared Statement 구문을 사용하게 되면, 사용자의 입력 값이 데이터베이스의 파라미터로 들어가기 전에DBMS가 미리 컴파일 하여 실행하지 않고 대기합니다. 그 후 사용자의 입력 값을 문자열로 인식하게 하여 공격쿼리가 들어간다고 하더라도, 사용자의 입력은 이미 의미 없는 단순 문자열 이기 때문에 전체 쿼리문도 공격자의 의도대로 작동하지 않습니다.

3. Error Message 노출 금지

공격자가 SQL Injection을 수행하기 위해서는 데이터베이스의 정보(테이블명, 컬럼명 등)가 필요합니다. 데이터베이스 에러 발생 시 따로 처리를 해주지 않았다면, 에러가 발생한 쿼리문과 함께 에러에 관한 내용을 반환헤 줍니다. 여기서 테이블명 및 컬럼명 그리고 쿼리문이 노출이 될 수 있기 때문에, 데이터 베이스에 대한 오류발생 시 사용자에게 보여줄 수 있는 페이지를 제작 혹은 메시지박스를 띄우도록 하여야 합니다.

4. 웹 방화벽 사용

웹 공격 방어에 특화되어있는 웹 방화벽을 사용하는 것도 하나의 방법입니다. 웹 방화벽은 소프트웨어 형, 하드웨어 형, 프록시 형 이렇게 세가지 종류로 나눌 수 있는데 소프트웨어 형은 서버 내에 직접 설치하는 방법이고, 하드웨어 형은 네트워크 상에서 서버 앞 단에 직접 하드웨어 장비로 구성하는 것이며 마지막으로 프록시 형은 DNS 서버 주소를 웹 방화벽으로 바꾸고 서버로 가는 트래픽이 웹 방화벽을 먼저 거치도록 하는 방법입니다.

### SQL vs NoSQL

RDBMS : 모든 데이터를 2차원 테이블 형태로 표현

- 장점
  - 스키마에 맞춰 데이터를 관리하기 때문에 데이터의 정합성을 보장
  - 명확하게 정의된 스키마, 데이터 무결성 보장
  - 관계는 각 데이터를 중복없이 한번만 저장
- 단점
  - 시스템이 커질수록 쿼리가 복잡해지고 성능이 저하되며 Scale-out이 어렵다(Scale-up만 가능)
  - 덜 유연함. 데이터 스키마를 사전에 계획하고 알려야 함. (나중에 수정하기 힘듬)
  - 관계를 맺고 있어서 조인문이 많은 복잡한 쿼리가 만들어질 수 있음
- 데이터 구조가 명확하고, 변경 될 여지가 없으며 스키마가 중요한 경우 사용하는 것이 좋다. 중복된 데이터가 없어(데이터 무결성) 변경이 용이하기 때문에 관계를 맺고 있는 데이터가 자주 변경이 이루어지는 시스템에 적합.

NoSQL : RDBMS와 반대로 데이터간의 관계를 정의하지 않고, 스키마 대신 컬렉션이라는 형태로 데이터를 관리한다.

- 장점
  - 스키마 없이 Key-Value형태로 데이터를 관리해 자유롭게 데이터를 관리할 수 있다
  - 데이터 분산이 용이하여 성능향상을 위한 Scale-up 뿐만아닌 Scale-out 또한 가능하다.
  - 스키마가 없어서 유연함. 언제든지 저장된 데이터를 조정하고 새로운 필드 추가 가능
  - 데이터는 애플리케이션이 필요로 하는 형식으로 저장됨. 데이터 읽어오는 속도 빨라짐
  - 수직 및 수평 확장이 가능해서 애플리케이션이 발생시키는 모든 읽기/쓰기 요청 처리 가능
- 단점
  - 데이터 중복이 발생할 수 있고, 데이터가 여러 컬렉션에 중복되어 있기 때문에 수정 시 모든 컬렉션에서 수행해야 함 (SQL에서는 중복 데이터가 없으므로 한번만 수행이 가능)
  - 스키마가 존재하지 않기 때문에 명확한 데이터 구조를 보장하지 않아서 데이터 구조 결정이 어려울 수 있다
  - 유연성으로 인해 데이터 구조 결정을 미루게 될 수 있음
  - 데이터 중복을 계속 업데이트 해야 함
- 정확한 데이터 구조를 알 수 없고, 데이터가 변경/확장 될 수 있는 경우 사용하는 것이 좋다. 데이터 중복이 발생할 수 있기 때문에 중복된 데이터가 변경될 시 모든 컬렉션에서 수정해야하기 때문에 Update가 많이 이루어지지 않는 시스템에 좋으며 Scale-out이 가능하다는 장점을 활요해 막대한 데이터를 저장해야해서 DB를 Scale-out해야하는 시스템에 적합

DB 확장 2가지 방법

1. Scale Out : 접속된 서버를 여러대 추가하여 처리 능력을 향상하는 방법, 수평 스케일. 서버가 여러 대가 되기 때문에 각 서버에 걸리는 부하를 균등하게 해주는 로드 밸런싱이 필수적. 서버 한 대가 다운되더라도 다른 서버로 서비스 제공이 가능. 각각의 처리는 단순하지만 다수의 처리를 동시 병행적으로 실시하지 않으면 안되는 경우 적합하다. 갱신 데이터의 정합성에 대한 유지 요건이 별로 어렵지 않은 경우 적합하다. 모든 서버가 동일한 데이터를 가지고 있어야하기에 데이터 변화가 적은 웹서버에 적합하다.

2. Scale Up : 서버에 CPU나 RAM 등을 추가하거나 고성능의 부품, 서버로 교환하는 방법. 예를 들어 하나의 처리 능력을 가진 서버 한 대를 7의 처리 능력을 가진 서버로 그 자체의 처리능력을 향상하는 방법, 수직 스케일. 서버 한대로 모든 부하가 집중되어 장애시 크게 영향 받을 수 있음. 한 대의 서버에서 모든 데이터를 처리하여 데이터 갱신이 빈번하게 일어나는 '데이터베이스 서버'에 적합하다(여러 대의 서버에서 데이터의 정합성을 유지하기 어렵다).

https://gyoogle.dev/blog/computer-science/data-base/Normalization.html
