## 기본 자료 구조

### 자료구조

자료구조 (Data Structure)란 자료에 효율적으로 접근하고 수정할 수 있도록 데이터를 구성하고 저장하는 방법. 프로그래밍에서 어떤 데이터 구조를 사용하느냐에 따라 코드 효율이 달라진다

저장되는 데이터의 형태에 따라 선형 자료구조와 비선형 자료구조로 구분

- 선형 자료 구조(데이터가 일렬로 나열) : array, linkedlist, stack, queue
- 비선형 자료 구조(데이터가 특정한 형태를 띔) : tree, graph

### Array(배열)

동일한 자료형의 데이터를 일렬로 나열한 자료구조

인덱스와 인덱스에 대응하는 데이터들로 이루어진 자료구조

- 장점
  첫 데이터의 위치에서 상대적인 위치(인덱스 번호)로 데이터를 접근하므로, 빠른 접근이 가능하다.
  - 인덱스 위치를 안다면, 상수 시간으로 접근 가능하다 O(1)
- 단점
  - 추가 : 데이터의 길이가 정해져 있으므로, 크기 이상의 데이터를 저장할 때 새로운 배열을 만들어야 한다.
  - 삭제 : 데이터를 삭제 할 경우, 뒤에 있는 데이터를 앞으로 당겨와야 하는 어려움이 있다
- 시간 복잡도
  - 데이터 조회 : O(1)
  - 데이터 삽입/삭제하기 : O(n)

### LinkedList(연결리스트)

떨어진 곳에 존재하는 데이터를 화살표로 연결해서 관리하는 데이터 구조

정해진 크기의 공간 없이, 필요할 때마다 데이터를 추가하고 삭제가 가능한 데이터 공간 (배열은 정해진 크기의 공간에 데이터를 나열해야만 하는 단점을 극복)

기본 요소

- 노드(Node): 데이터 저장 단위 (데이터 값, 포인터)로 구성
- 포인터(pointer): 각 노드 안에서, 다음이나 이전의 노드와의 연결 정보(주소)를 가지고 있는 공간, 다음 노드가 없을 경우 null 값

- 장점
  - 미리 데이터 공간을 미리 할당하지 않아도 됨. 배열은 미리 데이터 공간을 할당 해야 함.
- 단점
  - 연결을 위한 별도 데이터 공간이 필요하므로, 저장 공간 효율이 높지 않음
  - 연결 정보를 찾는 시간이 필요하므로 접근 속도가 느림
  - 중간 데이터 삭제 시, 앞뒤 데이터의 연결을 재구성해야 하는 부가적인 작업 필요
- 시간 복잡도
  - 데이터 조회 : O(n)
  - 데이터 삽입/삭제하기 : O(1)

### Stack(스택)

스택은 선형 자료구조의 일종으로 마지막에 저장한 데이터를 가장 먼저 꺼내게 되는 LIFO(Last In First Out)방식의 자료구조

한쪽 끝에서만 자료를 넣거나 뺄 수 있다

가장 나중에 쌓은 데이터를 가장 먼저 빼낼 수 있는 데이터 구조

Top이라는 위치에서 변화 일어남
Push : 요소 추가, O(1)
Pop : 요소 제거, O(1)

사용 예시 : 웹 브라우저의 방문기록(뒤로가기), 실행 취소(undo), 재귀함수 사용시 쌓이는 콜스택, DFS(깊이 우선 탐색)

LIFO(Last In, Fisrt Out) 또는 FILO(First In, Last Out)

미리 스택의 크기가 정해져 있다. 크기 이상 삽입시 stack overflow, 빈 스택에서 빼내려할 때 stack underflow 발생

### Queue(큐)

선형 자료구조의 일종으로 처음에 저장한 데이터를 가장 먼저 꺼내게 되는 FIFO(First In First Out)방식의 자료구조

줄을 서는 행위와 유사

사용 예시 : 프린터의 인쇄 대기, 콜센터 고객 대기 시간, BFS(너비 우선 탐색), 프로세스 스케줄링

큐의 양쪽 끝에서 변화 일어남
Enqueue : 맨 뒤에 요소 추가, O(1)
Dequeue : 맨 앞의 요소 삭제, O(1)

FIFO(First-In, First-Out) 또는 LILO(Last-In, Last-Out)

미리 큐의 크기가 정해져 있다. 크기 이상 삽입시 queue overflow, 빈 큐에서 빼내려할 때 queue underflow 발생

queue는 원형으로 사용할 수 있다.

### Tree(트리)

비선형 자료구조의 일종으로 노드(node)와 간선(edge)을 이용하여 사이클을 이루지 않도록 구성한 데이터 구조

사이클이 없는 그래프(DAG-Directed Acyclic Graph의 한 종류)

- 특징

  - 부모와 자식 노드의 관계로 표현
  - depth(깊이) : 루트 노드에서 어떤 노드에 도달하기 위해 거쳐야하는 간선 수
  - level(레벨) : 트리의 특정 깊이를 가지는 노드의 집합(루트 노드의 level은 0)
  - degree(차수) : 자식 노드의 개수
  - degree of tree(트리의 차수) : 트리의 최대 차수

- 종류

  - 이진 트리(Binary Tree) : 각 노드가 최대 2개의 자식을 갖는 트리(자식이 0개, 1개, 2개)

    - 순회
      - 전위 순회(Preorder) : 루트노드 -> 왼쪽 서브트리 -> 오른쪽 서브트리
      - 중위 순회(Inorder) : 왼쪽 서브트리 -> 루트 노드 -> 오른족 서브트리
      - 후위 순회(Postorder) : 왼쪽 서브트리 -> 오른쪽 서브트리 -> 루트 노드
      - 레벨 순회(Level-order) : 모든 노드를 낮은 레벨부터 차례대로 순회
    - 종류

      - 완전 이진 트리(Complete Binary Tree) : 마지막 레벨을 제외하고 모든 레벨이 완전히 채워진 이진트리. 마지막 레벨도 왼쪽에서 오른쪽으로 채워져야 한다.
      - 전 이진 트리(Full Binary Tree) : 모든 노드가 0개 또는 2개의 자식 노드를 갖는 트리
      - 포화 이진 트리(Perfect Binary Tree) : 모든 레벨이 노드로 꽉 차있는 트리. 전 이진트리의 성질도 만족해야함. 모든 말단 노드가 동일한 깊이 또는 레벨을 갖는다.
        트리의 노드 개수가 정확히 2^k-1개(k=트리 높이)
      - 이진 탐색 트리(Binary Search Tree) : 오름차순으로 정렬된 이진트리. 중복된 키 존재 X

        - 탐색 : 루트노드와 찾는 값 비교. 같다면 탐색 종료. 루트노드보다 찾는 값이 작으면 왼쪽 서브트리로 내려가고, 루트노드보다 찾는 값이 크면 오른쪽 서브트리로 내려간다. 각 서브트리로 내려가면서 반복하다 단말 노드까지 내려가도 발견하지 못했다면 트리에 없다
        - 삽입 : 탐색과 동일한 방법. 탐색에 실패시 그 자리에 새로운 요소 추가. 같은 이름의 키 발견시 중단(중복 키 허용X)
        - 삭제 : 삭제하려는 노드 종류에 따라 다름
          - 단말 노드 : 바로 삭제
          - 하나의 서브트리 가짐 : 그 서브트리를 옮겨다 붙임
          - 두 개의 서브트리 가짐 : 왼쪽 서브트리에 있는 가장 큰 값 또는 오른쪽 서브트리에 있는 가장 작은 값을 가지는 노드를 삭제하려는 노드 위치로 옮겨줌(한개의 노드만 옮김으로써 트리의 변동성 최소화)
        - 시간 복잡도 : O(logN)~O(N)(최악)

          이진 탐색 트리는 완전 이진트리가 아니기 때문에 한쪽으로 쏠려있는 형태의 트리 가능

          이러한 단점을 없애기 위해 균형 이진 탐색 트리 사용

          - AVL 트리 :
          - red-black 트리 :

      - Heap : 완전 이진 트리 형태를 가지며 최댓값이나 최솟값을 빠르게 찾기 위해 만들어진 자료구조

        힙은 맨 위에 있는 루트노드에 항상 최댓값 또는 최솟값이 위치하므로 최댓값과 최솟값을 O(1) 안에 찾을 수 있다

        부모 노드와 자식 노드의 키값 사이에는 대소관계가 존재

        최댓값이 꼭지점에 위치한 Max-Heap의 경우 부모 노드의 키값이 반드시 자식 노드의 키값보다 크고,
        반대로 최솟값이 꼭지점에 위치한 Min-Heap의 경우 부모 노드의 키값이 반드시 자식 노드의 키값보다 작다

        - 삽입 : 완전 이진 트리의 맨 마지막 노드에 이루어진다. 부모 노드와 서로 비교한 후 적절한 위치가 아니라면 서로의 자리를 바꾸며, 적절한 위치에 도달할 때까지 반복한다.
        - 삭제 : 루트 노드를 제거한다. 이후 완전 이진 트리의 마지막 노드를 루트 노드로 옮긴다. 루트노드들을 자식 노드들과 서로 비교한 후에 적절한 위치에 도달할 때까지 서로의 위치를 바꾼다.

  - 신장 트리(Spanning Tree) : 그래프 내의 모든 정점을 포함하는 트리

    최소 연결 부분 그래프 (n개의 정점을 n-1개의 간선으로 연결)

    특징 : 하나의 그래프에는 여러 개의 신장트리 존재 가능. 모든 정점들이 연결 되어있다. 사이클 X

    - 최소 신장 트리(Minimum Spanning Tree) : Spanning Tree 중에서 사용된 간선들의 가중치 합이 최소인 트리

      - 특징 : 간선의 가중치 합이 최소. 하나의 그래프에 여러 개의 최소신장트리가 존재할 수 있다

      - 그래프에서 최소 신장 트리를 찾는 알고리즘
        - Kruskal 알고리즘
        - Prim 알고리즘

### Priority Queue(우선순위 큐)

데이터에 우선순위를 부여하여 들어간 순서와 관계없이 우선순위가 높은 데이터가 먼저 나오는 큐

대부분의 경우 Heap을 이용하여 생성

- 각종 자료구조를 이용해 우선순위 큐를 만들 때의 시간복잡도
  - Array : 최댓값, 최솟값 찾는데 O(N), 삽입 삭제시 최악 O(N)
  - LinkedList : 최댓값, 최솟값 찾는데 O(N), 삽입 삭제시 최악 O(N)
  - BST : 한쪽으로 쏠린 이진 탐색의 트리의 경우 최악의 경우 최댓값, 최솟값 찾는데 O(N), 삽입 삭제시 O(N) 하지만 balanced할 경우 O(logN)
  - Heap : 완전 트리이기 때문에 최댓값, 최솟값 O(1), 삽입 삭제시 O(logN)
