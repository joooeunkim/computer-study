## 기본 자료 구조

### 자료구조

자료구조 (Data Structure)란 자료에 효율적으로 접근하고 수정할 수 있도록 데이터를 구성하고 저장하는 방법. 프로그래밍에서 어떤 데이터 구조를 사용하느냐에 따라 코드 효율이 달라진다

저장되는 데이터의 형태에 따라 선형 자료구조와 비선형 자료구조로 구분

- 선형 자료 구조(데이터가 일렬로 나열) : array, linkedlist, stack, queue
- 비선형 자료 구조(데이터가 특정한 형태를 띔) : tree, graph

### Array(배열)

동일한 자료형의 데이터를 일렬로 나열한 자료구조

인덱스와 인덱스에 대응하는 데이터들로 이루어진 자료구조

- 장점
  첫 데이터의 위치에서 상대적인 위치(인덱스 번호)로 데이터를 접근하므로, 빠른 접근이 가능하다.
  - 인덱스 위치를 안다면, 상수 시간으로 접근 가능하다 O(1)
- 단점
  - 추가 : 데이터의 길이가 정해져 있으므로, 크기 이상의 데이터를 저장할 때 새로운 배열을 만들어야 한다.
  - 삭제 : 데이터를 삭제 할 경우, 뒤에 있는 데이터를 앞으로 당겨와야 하는 어려움이 있다
- 시간 복잡도
  - 데이터 조회 : O(1)
  - 데이터 삽입/삭제하기 : O(n)

### LinkedList(연결리스트)

떨어진 곳에 존재하는 데이터를 화살표로 연결해서 관리하는 데이터 구조

정해진 크기의 공간 없이, 필요할 때마다 데이터를 추가하고 삭제가 가능한 데이터 공간 (배열은 정해진 크기의 공간에 데이터를 나열해야만 하는 단점을 극복)

기본 요소

- 노드(Node): 데이터 저장 단위 (데이터 값, 포인터)로 구성
- 포인터(pointer): 각 노드 안에서, 다음이나 이전의 노드와의 연결 정보(주소)를 가지고 있는 공간, 다음 노드가 없을 경우 null 값

- 장점
  - 미리 데이터 공간을 미리 할당하지 않아도 됨. 배열은 미리 데이터 공간을 할당 해야 함.
- 단점
  - 연결을 위한 별도 데이터 공간이 필요하므로, 저장 공간 효율이 높지 않음
  - 연결 정보를 찾는 시간이 필요하므로 접근 속도가 느림
  - 중간 데이터 삭제 시, 앞뒤 데이터의 연결을 재구성해야 하는 부가적인 작업 필요
- 시간 복잡도
  - 데이터 조회 : O(n)
  - 데이터 삽입/삭제하기 : O(1)

### Stack(스택)

스택은 선형 자료구조의 일종으로 마지막에 저장한 데이터를 가장 먼저 꺼내게 되는 LIFO(Last In First Out)방식의 자료구조

한쪽 끝에서만 자료를 넣거나 뺄 수 있다

가장 나중에 쌓은 데이터를 가장 먼저 빼낼 수 있는 데이터 구조

Top이라는 위치에서 변화 일어남
Push : 요소 추가, O(1)
Pop : 요소 제거, O(1)

사용 예시 : 웹 브라우저의 방문기록(뒤로가기), 실행 취소(undo), 재귀함수 사용시 쌓이는 콜스택, DFS(깊이 우선 탐색)

LIFO(Last In, Fisrt Out) 또는 FILO(First In, Last Out)

미리 스택의 크기가 정해져 있다. 크기 이상 삽입시 stack overflow, 빈 스택에서 빼내려할 때 stack underflow 발생

### Queue(큐)

선형 자료구조의 일종으로 처음에 저장한 데이터를 가장 먼저 꺼내게 되는 FIFO(First In First Out)방식의 자료구조

줄을 서는 행위와 유사

사용 예시 : 프린터의 인쇄 대기, 콜센터 고객 대기 시간, BFS(너비 우선 탐색), 프로세스 스케줄링

큐의 양쪽 끝에서 변화 일어남
Enqueue : 맨 뒤에 요소 추가, O(1)
Dequeue : 맨 앞의 요소 삭제, O(1)

FIFO(First-In, First-Out) 또는 LILO(Last-In, Last-Out)

미리 큐의 크기가 정해져 있다. 크기 이상 삽입시 queue overflow, 빈 큐에서 빼내려할 때 queue underflow 발생

queue는 원형으로 사용할 수 있다.

### Tree(트리)

비선형 자료구조의 일종으로 노드(node)와 간선(edge)을 이용하여 사이클을 이루지 않도록 구성한 데이터 구조

사이클이 없는 그래프(DAG-Directed Acyclic Graph의 한 종류)

- 특징

  - 부모와 자식 노드의 관계로 표현
  - depth(깊이) : 루트 노드에서 어떤 노드에 도달하기 위해 거쳐야하는 간선 수
  - level(레벨) : 트리의 특정 깊이를 가지는 노드의 집합(루트 노드의 level은 0)
  - degree(차수) : 자식 노드의 개수
  - degree of tree(트리의 차수) : 트리의 최대 차수

- 종류

  - 이진 트리(Binary Tree) : 각 노드가 최대 2개의 자식을 갖는 트리(자식이 0개, 1개, 2개)

    - 순회
      - 전위 순회(Preorder) : 루트노드 -> 왼쪽 서브트리 -> 오른쪽 서브트리
      - 중위 순회(Inorder) : 왼쪽 서브트리 -> 루트 노드 -> 오른족 서브트리
      - 후위 순회(Postorder) : 왼쪽 서브트리 -> 오른쪽 서브트리 -> 루트 노드
      - 레벨 순회(Level-order) : 모든 노드를 낮은 레벨부터 차례대로 순회
    - 종류

      - 완전 이진 트리(Complete Binary Tree) : 마지막 레벨을 제외하고 모든 레벨이 완전히 채워진 이진트리. 마지막 레벨도 왼쪽에서 오른쪽으로 채워져야 한다.
      - 전 이진 트리(Full Binary Tree) : 모든 노드가 0개 또는 2개의 자식 노드를 갖는 트리
      - 포화 이진 트리(Perfect Binary Tree) : 모든 레벨이 노드로 꽉 차있는 트리. 전 이진트리의 성질도 만족해야함. 모든 말단 노드가 동일한 깊이 또는 레벨을 갖는다.
        트리의 노드 개수가 정확히 2^k-1개(k=트리 높이)
      - 이진 탐색 트리(Binary Search Tree) : 오름차순으로 정렬된 이진트리. 중복된 키 존재 X

        - 탐색 : 루트노드와 찾는 값 비교. 같다면 탐색 종료. 루트노드보다 찾는 값이 작으면 왼쪽 서브트리로 내려가고, 루트노드보다 찾는 값이 크면 오른쪽 서브트리로 내려간다. 각 서브트리로 내려가면서 반복하다 단말 노드까지 내려가도 발견하지 못했다면 트리에 없다
        - 삽입 : 탐색과 동일한 방법. 탐색에 실패시 그 자리에 새로운 요소 추가. 같은 이름의 키 발견시 중단(중복 키 허용X)
        - 삭제 : 삭제하려는 노드 종류에 따라 다름
          - 단말 노드 : 바로 삭제
          - 하나의 서브트리 가짐 : 그 서브트리를 옮겨다 붙임
          - 두 개의 서브트리 가짐 : 왼쪽 서브트리에 있는 가장 큰 값 또는 오른쪽 서브트리에 있는 가장 작은 값을 가지는 노드를 삭제하려는 노드 위치로 옮겨줌(한개의 노드만 옮김으로써 트리의 변동성 최소화)
        - 시간 복잡도 : O(logN)~O(N)(최악)

          이진 탐색 트리는 완전 이진트리가 아니기 때문에 한쪽으로 쏠려있는 형태의 트리 가능

          이러한 단점을 없애기 위해 균형 이진 탐색 트리 사용

          - AVL 트리 :
          - red-black 트리 :

      - Heap : 완전 이진 트리 형태를 가지며 최댓값이나 최솟값을 빠르게 찾기 위해 만들어진 자료구조

        힙은 맨 위에 있는 루트노드에 항상 최댓값 또는 최솟값이 위치하므로 최댓값과 최솟값을 O(1) 안에 찾을 수 있다

        부모 노드와 자식 노드의 키값 사이에는 대소관계가 존재

        최댓값이 꼭지점에 위치한 Max-Heap의 경우 부모 노드의 키값이 반드시 자식 노드의 키값보다 크고,
        반대로 최솟값이 꼭지점에 위치한 Min-Heap의 경우 부모 노드의 키값이 반드시 자식 노드의 키값보다 작다

        - 삽입 : 완전 이진 트리의 맨 마지막 노드에 이루어진다. 부모 노드와 서로 비교한 후 적절한 위치가 아니라면 서로의 자리를 바꾸며, 적절한 위치에 도달할 때까지 반복한다.
        - 삭제 : 루트 노드를 제거한다. 이후 완전 이진 트리의 마지막 노드를 루트 노드로 옮긴다. 루트노드들을 자식 노드들과 서로 비교한 후에 적절한 위치에 도달할 때까지 서로의 위치를 바꾼다.

  - 신장 트리(Spanning Tree) : 그래프 내의 모든 정점을 포함하는 트리

    최소 연결 부분 그래프 (n개의 정점을 n-1개의 간선으로 연결)

    특징 : 하나의 그래프에는 여러 개의 신장트리 존재 가능. 모든 정점들이 연결 되어있다. 사이클 X

    - 최소 신장 트리(Minimum Spanning Tree) : Spanning Tree 중에서 사용된 간선들의 가중치 합이 최소인 트리

      - 특징 : 간선의 가중치 합이 최소. 하나의 그래프에 여러 개의 최소신장트리가 존재할 수 있다

      - 그래프에서 최소 신장 트리를 찾는 알고리즘
        - Kruskal 알고리즘 : 탐욕적인 방법을 이용하여 그래프의 모든 정점을 최소 비용으로 연결하는 최적 해답을 구하는 것. MST가 '최소 비용의 간선으로 구성되며 사이클을 포함하지 않음' 의 조건에 근거하여 각 단계에서 사이클을 이루지 않는 최소 비용 간선을 선택 한다. 즉, 간선 선택을 기반으로 하는 알고리즘
        - Prim 알고리즘 : 시작 정점에서부터 출발하여 MST 집합을 단계적으로 확장 해나가는 방법이다. 정점 선택을 기반으로 하는 알고리즘이다. 즉, 이전 단계에서 만들어진 신장 트리를 확장하는 방법

### Priority Queue(우선순위 큐)

데이터에 우선순위를 부여하여 들어간 순서와 관계없이 우선순위가 높은 데이터가 먼저 나오는 큐

대부분의 경우 Heap을 이용하여 생성

- 각종 자료구조를 이용해 우선순위 큐를 만들 때의 시간복잡도
  - Array : 최댓값, 최솟값 찾는데 O(N), 삽입 삭제시 최악 O(N)
  - LinkedList : 최댓값, 최솟값 찾는데 O(N), 삽입 삭제시 최악 O(N)
  - BST : 한쪽으로 쏠린 이진 탐색의 트리의 경우 최악의 경우 최댓값, 최솟값 찾는데 O(N), 삽입 삭제시 O(N) 하지만 balanced할 경우 O(logN)
  - Heap : 완전 트리이기 때문에 최댓값, 최솟값 O(1), 삽입 삭제시 O(logN)

### Indexed Tree & Segmented Tree

구간의 대표값을 구하는 이진 트리의 종류

Segmented Tree : 어떠한 배열이 주어졌을 때 각 구간의 대표값(합, 최대값 등)을 빠르게 구할 수 있는 자료구조. O(logN). 필요한 리프노드만 채움. 불완전 트리라서 특정 인덱스(node)로 지정 탐색이 어려움. 업데이트도 지정 업데이트가 불가능(루트노드부터 업데이트 필요)

Indexed Tree(FenwickTree) : 세그먼트 트리 처럼 각 구간의 대표값을 빠르게 구할 수 있다. 세그먼트 트리보다 구현하기 간단하고 속도가 빠르다.
리프노드를 모두 채워서 만듦. 특정 인덱스(node)로 지정 탐색이 가능. 업데이트도 지정 업데이트 가능(리프노드부터 업데이트 가능)

특징

- 세그먼트 트리는 구현하는 과정이 복잡하고 어렵다는 단점이 있다
- 인덱스 트리는 구현이 매우 간단하다
- 인덱스 트리를 활용하여 구간합을 구하는 과정도 𝑂(𝑙𝑜𝑔𝑁)의 시간 복잡도를 가진다
- 인덱스 트리는 세그먼트 트리에 비해서 메모리 효율성이 높다

### Trie

문자열을 빠르게 검색할 수 있는 자료구조

문자열을 저장하고 효율적으로 탐색하기 위한 트리 형태의 자료구조

예를 들어 'Datastructure'라는 단어를 검색하기 위해서는 제일 먼저 'D'를 찾고, 다음에 'a', 't', ... 의 순서로 찾으면 된다. 이러한 개념을 적용한 것이 트라이(Trie)

래딕스 트리(radix tree) or 접두사 트리(prefix tree) or 탐색 트리(retrieval tree)라고도 한다

K진 트리 구조

단어 사전을 트라이로 생성, 그 후 찾을 단어를 트라이를 사용해 검색

트라이의 root 노드는 항상 빈 문자열

문자열을 탐색할 때, 하나하나씩 전부 비교하면서 탐색을 하는 것보다 시간 복잡도 측면에서 훨씬 더 효율적이다

각 노드에서 자식들에 대한 포인터들을 배열로 모두 저장하고 있다는 점에서 저장 공간의 크기가 크다는 단점도 있다. (메모리 측면에서 비효율적일 수 있음!)

시간 복잡도

가장 긴 문자열 : L, 문자열의 수 : M 일 때

생성 시간복잡도 : M개 * L만큼 => O(M*L), 삽입 : O(L)

탐색 : O(L)

### B-Tree

트리 자료구조의 일종으로 이진 트리를 확장해 하나의 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 큰 트리 구조

이진트리에서 발전되어 모든 리프노드들이 같은 레벨을 가질 수 있도록 자동으로 밸런스를 맞추는 균형이진트리의 확장판

특징

1. 노드에는 2개 이상의 데이터(key)가 들어갈 수 있으며, 항상 정렬된 상태로 저장된다
2. 내부 노드는 M/2~M개의 자식을 가질 수 있다. 최대 M개의 자식을 가질 수 있는 B 트리를 M차 B트리라고 한다
3. 특정 노드의 데이터(key)가 k개라면, 자식노드의 개수는 k+1개여야 한다
4. 특정 노드의 왼쪽 서브트리는 특정 노드의 key보다 작은 값들로, 오른쪽 서브트리는 큰 값들로 구성된다
5. 노드 내에 데이터는 floor(M/2)-1개부터 최대 M-1개까지 포함될 수 있다
6. 모든 리프 노드들이 같은 레벨에 존재한다

이진트리보다 더 많은 데이터를 더 효율적으로 저장소에 담을 수 있다.
외부 검색에 적절한 자료구조
실제 입출력시 블럭단위로 데이터를 읽기 때문에, 하나의 블럭에 여러 데이터를 동시에 저장할 수 있다면 블럭을 보다 효율적으로 사용할 수 있다

### B+Tree

B-Tree는 탐색을 위해서 노드를 찾아서 이동해야한다는 단점을 가진다.
이러한 단점을 해소하고자 B+Tree는 같은 레벨의 모든 키 값들이 정렬되어있고, 같은 레벨의 sibling node는 연결리스트 형태로 되어있다.
따라서 특정 값을 찾아야한다면 leaf노드에 모든 자료들이 존재하고, 그 자료가 연결리스트로 연결되어있어서 탐색에 매우 유리하다

### Hash Function(해시 함수)

해시 함수는 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수

해시 함수를 수행하기 전의 원래 데이터를 key, 해시 함수를 수행한 결과 값을 해시 값(hash value)라고 한다.
이렇게 키를 해시 값으로 매핑하는 전체적인 과정을 해싱이라고 한다.
해시함수는 기본적으로 각각의 키에 대해 모두 다른 해시 값을 가진다.
만약 다른 키에 대해 해시 값이 중복된다면, 이를 해시 충돌(Collision)이라고 한다.

특징

- 키에 상관없이 고정된 길이의 해시값을 출력한다
- 눈사태 효과 : 입력값이 아주 조금만 변경되어도 해시값은 전혀 다른 값이 반환된다
- 해시값으로 다른 키를 유추할 수 없다
- 같은 키에 대해 항상 같은 해시값을 반환한다
- 키에 대해 해시값이 항상 1:1인 함수도 마냥 좋지만은 않다
  항상 1:1 대응이 되도록 만드는 것이 거의 불가능 하지만, 만들어도 그것은 array와 다를 것이 없고 메모리를 너무 많이 차지한다
  따라서 hash를 hash답게 사용하지 못하는 경우가 될 수 있다
  이것보다 해시 충돌을 최소화하는 방향으로 설계하고, 해시 충돌에 대비해 대응하는 방법을 만드는 것이 더 중요!

### Hash Collision(해시 충돌)

해시 충돌은 서로 다른 두개의 키가 같은 해시 값을 가질 때 나타난다.
해시충돌은 해시함수의 효율성을 떨어뜨리므로, 최대한 일어나지 않게 만드는 것이 중요하다.
하지만 해시 함수가 무한한 입력값을 받아 해시값을 도출해내는 경우, key는 무한, value는 한정적이기 때문에 비둘기집의 원리에 의해 해시 충돌은 항상 존재한다

시간 복잡도

- collision 없는 경우 : O(1)
- collision 많은 경우 : O(N)

충돌 해결 방법

- Open Address 방식(개방주소 방식, 공개주소 방식) : 해시 충돌이 발생하면, 다른 해시 버킷에 해당 자료를 삽입하는 방식
  collision이 발생하면 데이터를 저장할 장소를 찾는다

  - 데이터를 저장할 장소를 찾는 방법 3가지
    - Linear Probing(선형 조사) : 최초 해시값에 해당하는 버밋에 다른 데이터가 저장되어있으면, 해당 해시값에서 고정폭만큼 옮기면서 다음 해시값에 해당하는 버킷에 데이터가 있는지 확인. 만약 데이터가 있다면 데이터가 없는 버킷을 찾을 때까지 반복(만약 특정 해시 값 주변 버킷이 모두 채워져있는 상황이라면 Primary Clustering 문제에 취약, 조사를 많이 해야함)
    - Quadratic Probing(제곱 조사) : 선형 조사가 고정폭 만큼 이동하며 조사한다면, 제곱 조사는 이동 폭이 제곱수로 늘어난다. 제곱 조사는 선형 조사처럼 버킷이 몰려있는 경우는 모면할 수 있지만, 여러 개의 다른 키들이 모두 동일한 초기 해시값을 갖고 있는 Secondary Clustering에 취약, 초기 해시값이 같다면 다음으로 이동하여 액세스하는 위치 또한 모두 동일해서 효율성이 떨어짐.
    - Double Hashing(이중 해싱) : 이중 해싱은 조사항 해시 값의 규칙성을 없애서 clustering을 방지하는 기법. 2개의 해시함수를 준비해서 하나는 최초의 해시값을 얻을 때, 또 다른 하나는 해시 충돌이 일어났을 때 이동폭을 얻기 위해 사용. 이렇게 되면 최초 해시값이 같은 경우가 많더라도 이동폭이 달라지고, 이동폭이 같더라도 최초 해시값이 달라져 Primary Clustering 모두 완화 가능

- Separate Chaining 방식(개별 분리 연결법) :버킷에 데이터를 삽입하다가 충돌이 발생하면 연결리스트나 tree를 이용해서 연결 시키는 방식. 해시 충돌이 잘 발생하지 않도록 보조 해시 함수를 통해 조정한다면 worst case의 빈도를 줄일 수 있다(open address 방식은 해시 버킷 채운 밀도가 높아질 수록 worst case 발생 빈도가 높아지기 때문에 느리다)

  충돌을 대비해서 미리 공간을 잡아놓을 필요가 없지만, 검색할 때 리스트를 탐색해야해서 탐색 속도가 느려진다

  보조 해시 함수(Supplement Hash Function) : 보조 해시 함수의 목적은 키(key)의 해시 값을 변형하여 해시 충돌 가능성을 줄이는 것

  구현방식 2가지

  - 연결리스트를 사용하는 방식(LinkedList) : 각각의 버킷들을 연결리스트로 만들어 collision이 발생하면 해당 버킷의 리스트에 추가하는 방식
    연결리스트의 특징을 이어받아 삭제 또는 삽입이 간단. 작은 데이터들을 저장할 때 연결리스트 자체의 오버헤드가 부담. 버킷을 계속해서 사용하는 open address 방식에 비해 테이블의 확장을 늦출 수 있다

  - Tree를 사용하는 방식(Red-Black Tree) : 기본적인 알고리즘은 separate chaining 방식과 동일하며, 연결리스트 대신 트리를 사용
    연결리스트를 사용할 것인지 트리를 사용할 것인지에 대한 기준은 하나의 해시 버킷에 할당된 key-value 쌍의 개수로 판단
    - 데이터의 개수가 적다면 연결리스트 사용이 유리(트리는 메모리 사용량이 많아서, 메모리 측면에서 데이터가 적을 때 연결리스트 사용)
      - 데이터가 적다는 기준 : 6개,8개를 기준.

- 공통점 : worst case 시간복잡도 O(M). 하지만 open address 방식은 연속된 공간에 데이터를 저장하기 때문에 separate chaining에 비해 캐시 효율 높다

- open addressing : ruby, python
- separate chaining : C++, java, Go

- 결론 : 데이턱의 개수가 충분히 적을 때(6,8개 이하) open address를 쓴다. 왜냐하면 연속된 공간에 데이터 저장하기 떄문에 separate chaining에 비해 캐시 효율이 높기 때문이다. 위의 경우를 제외하면, 테이블의 확장을 줄일 수 있기 때문에 separate chaining을 사용한다

  - 해시 버킷 동적 확장 : 해시 버킷의 갯수가 적다면 메모리 사용을 아낄 수 있지만, 해시 충돌로 인해 성능상 손실이 발생한다. 따라서 hashmap은 key-value쌍 데이터 개수가 일정 개수 이상이 되면(버킷 개수의 0.75가 되면) 해시 버킷의 개수를 2배로 늘려, 해시 충돌로 인한 성능 손실 문제를 어느정도 해결한다.

### Hash Algorithm(해시 알고리즘)

해시 알고리즘은 해시 함수에서 사용되는 알고리즘

해시 알고리즘에 따라 해시함수 성능이 좌우된다

크게 MD(Message-Direct) Algorithm과 SHA(Secure Hash) Algorithm이 있다

- MD5
  - 임의의 길이의 입력을 받아서 128비트 길이의 해시값을 출력하는 알고리즘
  - MD5는 단방향 암호화이기 때문에 출력값에서 입력값을 복원할 수 없다
  - 패스워드 암호화에서 많이 사용되고, 패스워드를 MD5로 해시해서 나온 값을 저장한다
  - 현재는 MD5를 보안 관련용도로 쓰는 것을 권장하지 않으며, 심각한 보안문제 야기할 수 있다
- SHA
  - 1993년 미국 NSA가 제작하고 NIST에서 표준으로 채택한 해시함수
  - SHA-0이 표준으로 되었으나 위험 발견 후 보완 후 SHA-1이 발표되어 널리 사용
  - SHA-0, SHA-1 모두 160비트 해시 값을 사용(SHA-1 역시 해시 충돌 위험성 발견되어 차세대 버전으로 넘어감)
  - 2001년 SHA-2버전 출시. 해시 길이에 따라 SHA-225, SHA-256, SHA-384, SHA-512를 선택 가능(해시 길이가 길 수록 안전하다)
  - 2012년 더 안정성 높은 SHA-3 출시

### Hash Table(해시 테이블) / Hash Map(해시 맵)

해시테이블이란, 해시함수를 사용하여 키를 해시값으로 매핑하고 이 해시값을 인덱스 또는 주소로 삼아 데이터의 값을 저장하는 자료구조
이때 데이터가 저장되는 곳을 버킷(bucket) 또는 슬롯(slot)이라고 한다
해시 테이블ㄹ의 기본 연산은 삽입, 삭제, 탐색

장점

- 적은 리소스로 많은 데이터를 효율적으로 관리가 가능하다
  해시 테입르에서는 1개의 키에 대해 1개의 버킷을 가지고, 버킷의 위치(index)를 키의 해시값으로 가진다
- 해시 함수는 동일한 키에 대해 항상 동일한 해시값을 반환하고, 이러한 해시값을 도출해내는데 시간이 오래걸리지 않는다(상수시간)
  해시 테이블은 이런 해시값을 index로 사용함으로써 모든 데이터를 탐색하지 않고 index를 통해 데이터에 바로 젖ㅂ근하여 빠른 검색속도를 가진다
- 1개의 키를 통해 1개의 버킷에만 접근이 가능하여, 적은 리소스로 많은 데이터를 효율적으로 관리 가능

시간 복잡도(average 케이스에 대해 - 모든 경우에 대한 것이 아닌 이유는 해시 충돌이 있기 때문)

- 데이터 접근(삽입, 삭제, 탐색) : O(1)

### Java Hashmap, Hashtable

Map이라는 자바 내 인터페이스를 구현한 구현체 입니다.
Map은 key-value 값을 가지는 자료구조이며, key는 유일한 값, value는 중복을 허용하는 구조를 가지고 있습니다.

- 사용 이유: 빠른 검색을 위해서 사용합니다. 보통 검색을 하기 위해서는 배열의 저장된 값을 선형탐색 하거나, 정렬된 배열에서는 이진 탐색을 이용하여 O(n) ~ O(logn) 만큼의 시간이 소요되는데, Hashmap을 사용하게 되면 삽입, 검색에 O(1)만큼의 시간이 소요되어 효율적입니다.

- 동작 원리 : key-value 값을 설정하게 되면 해시 함수를 통해 해시값(int형)에 해당하는 인덱스로 접근하게 됩니다. 그곳엔 buckets라는 녀석들이 존재하는데, value 값을 여기에 저장합니다. 하지만 key는 무한, value는 한정적이기 때문에 비둘기 집의 원리 때문에 해시 충돌이 일어나게 되어 있습니다.

- 공통점 : 둘다 map 인터페이스를 구현한 구현체임은 같다

- 차이점
  - hashtable
    - collection 프레임웍이 만들어지기 전부터 존재했고, 자바에서 해시테이블을 구현한 클래스 종 가장 오래. 따라서 hashmap과 사용법 거의 동일
    - 스레드부터 안전하여 어플리케이션간의 여러 스레드간의 공유가 가능(멀티 쓰레드일 경우에 써라)
    - null값 허용X
    - 보조 해시 함수를 사용하지 않는다
  - hashmap
    - 동기화가 되어있지 않으며, 추가 코드로 동기화를 헤주어야 스레드간 공유가 가능하다
    - key, value 모두 null값 허용
    - 따라서 동기화되지 않거나, 단일 스레드 응용프로그램에 대해 hashmap을 사용해야 한다
    - 보조 해시 함수를 사용한다(collision 덜 발생)
